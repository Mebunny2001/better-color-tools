@use 'sass:color';
@use 'sass:list';
@use 'sass:math';
@use 'sass:map';
@use 'sass:meta';
@use 'sass:string';

/// Mix colors through the Oklab space
///
/// @param {color} $color1
/// @param {color} $color2
/// @param {float} $weight [0.5] Mix strength (`0` = $color1, `0.5` = 50–50, `1` = $color2)
/// @returns {color} Mix result
@function mix($color1, $color2, $weight: 0.5) {
  @if $weight == 0 {
    @return $color1;
  }
  @if $weight == 1 {
    @return $color2;
  }

  $w1: 1 - $weight;
  $w2: $weight;

  $oklab1: rgbToOklab($color1);
  $oklab2: rgbToOklab($color2);

  $labmix: (
    'l': map.get($oklab1, 'l') * $w1 + map.get($oklab2, 'l') * $w2,
    'a': map.get($oklab1, 'a') * $w1 + map.get($oklab2, 'a') * $w2,
    'b': map.get($oklab1, 'b') * $w1 + map.get($oklab2, 'b') * $w2,
  );

  $rgb: oklabToRGB($labmix);
  @return rgba($rgb, color.alpha($color1) * $w1 + color.alpha($color2) * $w2); // don’t forget the alpha channel!
}

/// Convert sRGB to Oklab
///
/// @param {color} $color
/// @returns {map} Map of l, a, b
@function rgbToOklab($color) {
  // sRGB -> Linear RGB
  $r: __degamma(math.div(color.red($color), 255));
  $g: __degamma(math.div(color.green($color), 255));
  $b: __degamma(math.div(color.blue($color), 255));

  // Linear RGB -> LMS
  $lms: (
    'l': 0.4122214708 * $r + 0.5363325363 * $g + 0.0514459929 * $b,
    'm': 0.2119034982 * $r + 0.6806995451 * $g + 0.1073969566 * $b,
    's': 0.0883024619 * $r + 0.2817188376 * $g + 0.6299787005 * $b,
  );

  // LMS -> Oklab
  $l: map.get($lms, 'l');
  $m: map.get($lms, 'm');
  $s: map.get($lms, 's');
  $third: math.div(1, 3);
  @return ('l': math.pow(0.2104542553 * $l + 0.793617785 * $m - 0.0040720468 * $s, $third), 'a': math.pow(1.9779984951 * $l - 2.428592205 * $m + 0.4505937099 * $s, $third), 'b': math.pow(0.0259040371 * $l + 0.7827717662 * $m - 0.808675766 * $s, $third));
}

/// Convert Oklab map to sRGB
///
/// @param {map} Map of l, a, b
/// @returns {color} sRGB color
@function oklabToRGB($oklab) {
  @if meta.type-of($oklab) != 'map' {
    @error "Must provide map of \"l\", \"a\", \"b\" values";
  }

  // Oklab -> LMS
  $l: map.get($oklab, 'l');
  $a: map.get($oklab, 'a');
  $b: map.get($oklab, 'b');
  $lms: (
    'l': math.pow($l + 0.3963377774 * $a + 0.2158037573 * $b, 3),
    'm': math.pow($l - 0.1055613458 * $a - 0.0638541728 * $b, 3),
    's': math.pow($l - 0.0894841775 * $a - 1.291485548 * $b, 3),
  );

  // LMS -> Linear RGB
  $l: map.get($lms, 'l'); // overwrite but whatever
  $m: map.get($lms, 'm');
  $s: map.get($lms, 's');

  $r: math.max(4.0767416621 * $l - 3.3077115913 * $m + 0.2309699292 * $s, 0);
  $g: math.max(-1.2684380046 * $l + 2.6097574011 * $m - 0.3413193965 * $s, 0);
  $b: math.max(-0.0041960863 * $l - 0.7034186147 * $m + 1.707614701 * $s, 0);

  // Linear RGB -> sRGB
  @return rgb(__gamma($r) * 255, __gamma($g) * 255, __gamma($b) * 255);
}

@function __degamma($value) {
  @if $value <= 0.04045 {
    @return math.div($value, 12.92);
  }
  @return math.pow(math.div($value + 0.055, 1.055), 2.4);
}

@function __gamma($value) {
  @if $value <= 0.0031308 {
    @return math.clamp($value * 12.92, 0, 1);
  }
  @return math.clamp(1.055 * math.pow($value, math.div(1, 2.4)) - 0.055, 0, 1);
}

/// Relatively lighten color via Oklab. Produces better results than Sass’ lighten().
///
/// @param {color} $color
/// @param {float} $weight [0.5] Lightness strength (`0` = $color; `1` = white; `-1` = black)
/// @returns {color} Lightened color
@function lighten($color, $weight: 0.5) {
  @if $weight >= 0 {
    @return mix($color, #fff, $weight);
  } @else {
    @return darken($color, -$weight);
  }
}

/// Relatively lighten color via Oklab. Produces better results than Sass’ lighten().
///
/// @param {color} $color
/// @param {float} $weight [0.5] Darkness strength (`0` = $color; `1` = black; `-1` = white)
/// @returns {color} Darkened color
@function darken($color, $weight: 0.5) {
  @if $weight >= 0 {
    @return mix($color, #000, $weight);
  } @else {
    @return lighten($color, -$weight);
  }
}

/// Turn any color into P3 (supporting browsers only)
/// (https://webkit.org/blog/10042/wide-gamut-color-in-css-with-display-p3/)
///
/// @param {color} $color
/// @returns {string} P3 color string
@function p3($color) {
  $r: math.div(color.red($color), 255);
  $g: math.div(color.green($color), 255);
  $b: math.div(color.blue($color), 255);
  $a: color.alpha($color);
  @if $a == 1 {
    @return #{color(display-p3 $r $g $b)};
  } @else {
    @return #{color(display-p3 $r $g $b/$a)};
  }
}

/// Get perceived lightness of a color. Produces far better results than HSL.
///
/// @param {color} $color
/// @returns {float} Perceived lightness from `0` (dark) to `1`
@function lightness($color) {
  $oklab: rgbToOklab($color);
  @return map.get($oklab, 'l');
}

/// Quickly generate fallbacks for a CSS property. Useful for experimental syntax and partial support.
/// ex: `@include better.fallback(color, better.p3(#c4432b), #c4432b);`
///
/// @param {string} $property - The CSS property
/// @param {string} $values... - Specify desired values in decreasing order of preference
@mixin fallback($property, $values...) {
  @if list.length($values) < 2 {
    @error "Must specify at least 2 values for fallback()";
  }
  @for $i from list.length($values) through 1 {
    #{$property}: list.nth($values, $i);
  }
}
